---
title: Using Freesurfer annotation files to plot in R
author: 'Dr. Mowinckel'
date: '2020-04-30'
output:
  html_document:
    keep_md: yes
categories:
  - Neuroimaging
  - R
tags:
  - Plots
featured_image: '/blog/2020-04-30-using-freesurfer-annotation-files-to-plot-in-r_files/figure-html/featured-1.png'
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>When you work with neuroimaging data like I do, you often find your self swapping back and forth between R and the imaging software of your choise.
For me, that is usually <a href="https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/">FSL</a> or <a href="https://surfer.nmr.mgh.harvard.edu/">Freesurfer</a>.
Since the resolution of the brain we have is quite large and 3 dimensional, we often reduce the data to segments that meaningfully go together.
For instance, areas of the brain that control language or visual processing, or areas of the brain with similar structural properties.
If you have worked with Freesurfer, the Desikan Killany coortical atlas (aparc) is likely well known to you.
This is an atlas that consist of 36 segments, which are well-defined (<a href="https://surfer.nmr.mgh.harvard.edu/ftp/articles/fischl04-parcellation.pdf">Automatically Parcellating the Human Cerebral Cortex</a>, Fischl et al., (2004). Cerebral Cortex, 14:11-22.)</p>
<p><img src="https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation?action=AttachFile&amp;do=get&amp;target=annot-desikan.jpg" /><!-- --><img src="https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation?action=AttachFile&amp;do=get&amp;target=annot-desikan-m.jpg" /><!-- --></p>
<p>Since the brain is full of sulci (grooves), we often inflate the brain surface so we can more clearly see the entire brain.
This is what is shown above.
For those who have followed some of my posts, you might recognise this image to be similar to the default image from our <a href="https://lcbc-uio.github.io/ggseg/">ggseg</a> package.</p>
<pre class="r"><code>library(ggseg)</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<pre class="r"><code>ggseg(atlas = dk, mapping = aes(fill=region),
      position = &quot;stacked&quot;, colour = &quot;black&quot;, 
      show.legend = FALSE) + 
  scale_fill_brain(&quot;dk&quot;)</code></pre>
<p><img src="/blog/2020-04-30-using-freesurfer-annotation-files-to-plot-in-r/index_files/figure-html/featured-1.png" width="672" /></p>
<p>Similarly is our package <code>ggseg3d</code>, where you can render the proper 3d version using plotly.</p>
<pre class="r"><code>library(dplyr, warn.conflicts = FALSE)
library(ggseg3d)
p &lt;- ggseg3d(atlas = dk_3d) %&gt;% 
  pan_camera(camera = &quot;right lateral&quot;) %&gt;% 
  remove_axes()</code></pre>
<pre class="r"><code>p</code></pre>
<iframe src="ggseg_1_widget.html" width="100%" height="500px"></iframe>
<p>That is some nerdy fun!</p>
<p>But getting to the point of having this data was quite some road.
And I’d like to share that road with you now.
This entire pipeline is made into a function in our companion package <a href="https://lcbc-uio.github.io/ggsegExtra/">ggsegExtra</a>, the <code>aparc_2_mesh()</code> function.</p>
<div id="making-freesurfer-files-into-plotly-mesh-files." class="section level1">
<h1>Making Freesurfer files into plotly mesh files.</h1>
<p>First step in this journey, was to take a binary file type that exists in Freesurfer called an annotation file (<code>annot</code>).
The <code>annot</code> file contains information about the segments of the atlas, their colours etc.
I had never worked with binary files before, and if is was not for the fact that I had some early PhD days where I did do some Matlab scripting, I’d likely not get any further.
Luckily, I was able to decompose Freesurfer’s own matlab script reading this binary file, and translate it into R.
The result can be seen <a href="https://github.com/muschellij2/freesurfer/blob/master/R/read_annotation.R">here</a> in the R package <a href="https://github.com/muschellij2/freesurfer">freesurfer</a> by <a href="https://github.com/muschellij2">John Muschelli</a>.
This was the first time I contributed a real piece of code to another persons package, and John has graciously added me to the list of authors for it.
This makes me quite stoked!</p>
<p>The function resturns a list of three things:<br />
1. a vector of vertices<br />
2. a vector of labels<br />
3. a data.frame of colours and region names</p>
<pre class="r"><code># remotes::install_github(&quot;muschellij2/freesurfer&quot;)
annot_file &lt;- &quot;/Applications/freesurfer/subjects/fsaverage5/label/lh.aparc.annot&quot;
dk_annot &lt;- freesurfer::read_annotation(annot_file)</code></pre>
<pre><code>## Reading from version 2 
## colortable with 36 entries read (originally /autofs/space/amaebi_026/users/buckner_cortical_atlas/scripts/colortable_final.txt )</code></pre>
<pre class="r"><code>str(dk_annot)</code></pre>
<pre><code>## List of 3
##  $ vertices  : int [1:10242] 0 1 2 3 4 5 6 7 8 9 ...
##  $ label     : int [1:10242] 14423100 9221140 10542100 8204875 14423100 1351760 9182740 11832480 1639705 3296035 ...
##  $ colortable:&#39;data.frame&#39;:  36 obs. of  6 variables:
##   ..$ label: chr [1:36] &quot;unknown&quot; &quot;bankssts&quot; &quot;caudalanteriorcingulate&quot; &quot;caudalmiddlefrontal&quot; ...
##   ..$ R    : int [1:36] 25 25 125 100 120 220 220 180 220 180 ...
##   ..$ G    : int [1:36] 5 100 100 25 70 20 20 220 60 40 ...
##   ..$ B    : int [1:36] 25 40 160 0 50 100 10 140 220 120 ...
##   ..$ A    : int [1:36] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ code : num [1:36] 1639705 2647065 10511485 6500 3294840 ...</code></pre>
<p>This data we will need to create brain segments per row in the data.frame returned.
Since R is more happy with hexidecimal colour codes, we can go ahead and turn RGB to hex</p>
<pre class="r"><code>dk_annot$colortable &lt;- mutate(dk_annot$colortable,
                     hex = grDevices::rgb(R, G, B, 
                                          maxColorValue = 255)
)

as_tibble(dk_annot$colortable) </code></pre>
<pre><code>## # A tibble: 36 x 7
##    label                       R     G     B     A     code hex    
##    &lt;chr&gt;                   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;  
##  1 unknown                    25     5    25     0  1639705 #190519
##  2 bankssts                   25   100    40     0  2647065 #196428
##  3 caudalanteriorcingulate   125   100   160     0 10511485 #7D64A0
##  4 caudalmiddlefrontal       100    25     0     0     6500 #641900
##  5 corpuscallosum            120    70    50     0  3294840 #784632
##  6 cuneus                    220    20   100     0  6558940 #DC1464
##  7 entorhinal                220    20    10     0   660700 #DC140A
##  8 fusiform                  180   220   140     0  9231540 #B4DC8C
##  9 inferiorparietal          220    60   220     0 14433500 #DC3CDC
## 10 inferiortemporal          180    40   120     0  7874740 #B42878
## # … with 26 more rows</code></pre>
<p>Next step is to convert the annotation file to what <a href="https://brainder.org/">Anderson Winkler</a> so astoutly has called <code>data-per-vertex</code> file, or a <code>dpv</code> for short.
This is technically an <code>ascii</code> file.
This is what we will use to combine all vertices into triangular meshes for 3d rendering.
For this I made a function called <code>ggsegExtra::annot2dpv</code> for simplicity.
What is does is map the labels from the annotation file, restructure the labels so that we get a matrix with 5 columns.</p>
<pre class="r"><code># remotes::install_github(&quot;LCBC-UiO/ggsegExtra&quot;)
dpv &lt;- ggsegExtra::annot2dpv(annot_file, &quot;annot.dpv&quot;)</code></pre>
<pre><code>## Reading from version 2 
## colortable with 36 entries read (originally /autofs/space/amaebi_026/users/buckner_cortical_atlas/scripts/colortable_final.txt )</code></pre>
<pre class="r"><code>as_tibble(dpv)</code></pre>
<pre><code>## # A tibble: 10,242 x 5
##       V1    V2    V3    V4    V5
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1     0     0     0     0    25
##  2     1     0     0     0    30
##  3     2     0     0     0    29
##  4     3     0     0     0    28
##  5     4     0     0     0    25
##  6     5     0     0     0    32
##  7     6     0     0     0    12
##  8     7     0     0     0    26
##  9     8     0     0     0     1
## 10     9     0     0     0    13
## # … with 10,232 more rows</code></pre>
<p>This file is the basis for the triangular mesh we will soon make.
The format tok me a while to understand, but it has two main parts:<br />
1. is X number of rows with information of the <em>face</em> of the triangle (i.e. the surface area between three points)<br />
2. is Y number of rows with information about the <em>vertices</em> for the triangles (i.e. the three connecting dots)</p>
<p>Now that we have mapping of vertices and faces, we also need a surface to project on to.
In Freesurfer, we have quite some surfaces to choose from, but we will go with inflated for now, and use the left hemisphere (<code>lh</code>).
This file we also need to convert into an ascii file, with the convenient <code>surf3asc()</code> function we made.</p>
<pre class="r"><code>surf_file &lt;- &quot;/Applications/freesurfer/subjects/fsaverage5/surf/lh.inflated&quot;
surf &lt;- ggsegExtra::surf2asc(surf_file, &quot;~/Desktop/surf.dpv&quot;)</code></pre>
<pre><code>## Saving ~/Desktop/surf.dpv</code></pre>
<pre class="r"><code>str(surf)</code></pre>
<pre><code>## List of 2
##  $ vertices:&#39;data.frame&#39;:    10242 obs. of  4 variables:
##   ..$ V1: num [1:10242] -5.84 16.43 30.06 5.29 -36.14 ...
##   ..$ V2: num [1:10242] 2.5 -64.2 16.6 92.2 24.7 ...
##   ..$ V3: num [1:10242] 57.65 54.94 43.2 13.27 -2.76 ...
##   ..$ V4: int [1:10242] 0 0 0 0 0 0 0 0 0 0 ...
##  $ faces   :&#39;data.frame&#39;:    10239 obs. of  4 variables:
##   ..$ V1: num [1:10239] -5.19 -4.16 -3.1 -2.28 -1.44 ...
##   ..$ V2: num [1:10239] -12.2 -11.7 -11.1 -13.7 -16.3 ...
##   ..$ V3: num [1:10239] -60.7 -60.1 -59.4 -57.5 -55.6 ...
##   ..$ V4: int [1:10239] 0 0 0 0 0 0 0 0 0 0 ...</code></pre>
<p>This format we will turn into Stanford Polygon files (<code>.ply</code>) which are quite common for mesh data.
You can read more about this format in Anderson Winklers <a href="https://brainder.org/tag/ply/">blogpost</a>.</p>
<p>This is quite an easy transformation, as it’s actually just chaging the text in the ascii little, but a function always makes transformations easier!</p>
<pre class="r"><code>ply &lt;- ggsegExtra::asc2ply(&quot;~/Desktop/surf.dpv&quot;,&quot;~/Desktop/surf.ply&quot;)
str(ply)</code></pre>
<pre><code>##  chr [1:30731] &quot;ply&quot; &quot;format ascii 1.0&quot; &quot;element vertex 10242&quot; ...</code></pre>
<p>The fun part is that, despite this being a file made completely of text and might seem very niche, Mac’s Finder recognises this format as a 3d object and can preview it for you!
Albeit in a strange angle, there it is!</p>
<div class="figure">
<img src="ply_ss.png" alt="" />
<p class="caption">screenshot of ply file in Finder</p>
</div>
<p>The next step is to project the colours from the regions we know of, onto the currently white faces of the meshes.
This, is easier said than done.
While I would have loved to do this on a face-by-face way, I have yet to find a way to do so.
The only way I know how to do this next step, and by no means truly understand what is happening, is by scouring through Anderson Winklers <a href="https://github.com/andersonwinkler/areal">areal scripts</a>.
He does seem to have a graps of face-mapping though, so I’m preparing to contact him to learn more about it.</p>
<p>This next step, will split the <code>.ply</code> file into several <code>.ply</code> files based on the information in the labels we previously made.
The function <code>surfsplit()</code> is a doozy, and while it works, I can confidently say I dont know why.
It is a piece of magic Anderson made, that I translated to R.
I sat for several days with R and Matlab side by side, carefully making sure I was getting the same output for the functions.
It was fun and gruelling at the same time.
This function is so very specifically tailored to work within the overarching pipeline, that I have not made it an exported function.
It works only internally.</p>
<p>Sorry about that! But it really is such a piece I think not alot of people will find it particularly interesting.</p>
<p>Once all .ply files are generated, all of them are collected in R using a nested data.frame.</p>
<p>Running the entire pipeline, selecting the subject <code>fsaverage5</code>, right hemisphere, on an inflasted surface, for the <code>aparc</code>(Desikan Killany) atlas.</p>
<pre class="r"><code>subj &lt;- &quot;fsaverage5&quot;
fs_subj_dir &lt;- &quot;/Applications/freesurfer/subjects/&quot;

dk_atlas &lt;- ggsegExtra::aparc_2_mesh(subject = subj,
                                     hemisphere = &quot;rh&quot;,
                                     surface = &quot;inflated&quot;,
                                     annot = &quot;aparc&quot;,
                                     subjects_dir = fs_subj_dir,
                                     annot_dir = file.path(fs_subj_dir, subj, &quot;label&quot;),
                                     output_dir = &quot;~/Desktop/&quot;,
                                     cleanup = FALSE,
                                     verbose = FALSE )</code></pre>
<pre class="r"><code>dk_atlas</code></pre>
<pre><code>## # A tibble: 36 x 9
##    atlas surf   hemi  region       colour  mesh     label       roi   annot     
##    &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;   &lt;list&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;     
##  1 dk_3d infla… left  &lt;NA&gt;         &lt;NA&gt;    &lt;named … lh_unknown  0001  unknown   
##  2 dk_3d infla… left  bankssts     #196428 &lt;named … lh_bankssts 0002  bankssts  
##  3 dk_3d infla… left  caudal ante… #7D64A0 &lt;named … lh_caudala… 0003  caudalant…
##  4 dk_3d infla… left  caudal midd… #641900 &lt;named … lh_caudalm… 0004  caudalmid…
##  5 dk_3d infla… left  corpus call… #784632 &lt;named … lh_corpusc… 0005  corpuscal…
##  6 dk_3d infla… left  cuneus       #DC1464 &lt;named … lh_cuneus   0006  cuneus    
##  7 dk_3d infla… left  entorhinal   #DC140A &lt;named … lh_entorhi… 0007  entorhinal
##  8 dk_3d infla… left  fusiform     #B4DC8C &lt;named … lh_fusiform 0008  fusiform  
##  9 dk_3d infla… left  inferior pa… #DC3CDC &lt;named … lh_inferio… 0009  inferiorp…
## 10 dk_3d infla… left  inferior te… #B42878 &lt;named … lh_inferio… 0010  inferiort…
## # … with 26 more rows</code></pre>
<p>Within the <code>mesh</code> column, are both the vertices and faced needed to make the mesh for plotting.
In a <em>very</em> simplified version, the <code>ggseg3d()</code> function just loops through each segment and adds it as a trace to plotly.</p>
<pre class="r"><code>p = plotly::plot_ly()
for (tt in 1:nrow(dk_atlas)) {
  
  p = plotly::add_trace(p,
                        
                        # map vertices
                        x = dk_atlas$mesh[[tt]]$vertices$x, 
                        y = dk_atlas$mesh[[tt]]$vertices$y, 
                        z = dk_atlas$mesh[[tt]]$vertices$z, 
                        
                        # map faces
                        i = dk_atlas$mesh[[tt]]$faces$i - 1, 
                        j = dk_atlas$mesh[[tt]]$faces$j - 1, 
                        k = dk_atlas$mesh[[tt]]$faces$k - 1, 
                        
                        facecolor = rep(dk_atlas$colour[tt], nrow(dk_atlas$mesh[[tt]]$faces)), 
                        type = &quot;mesh3d&quot;, 
                        showscale = FALSE
                        )
}</code></pre>
<pre class="r"><code>p</code></pre>
<iframe src="ggseg_2_widget.html" width="100%" height="500px"></iframe>
<p>This tok me well over a week to pan out. :)
The translations of Andersons’ scripts, the trying desperately to be able to map the faces to colour without splitting up into multiple <code>.ply</code>s.
I learned so much, and it was really a fun challenge!</p>
<p>I hope the function to make the atlas is easy enough for you who need it, and that you will be able to create your own atlases compatible with ggseg3d!</p>
</div>
